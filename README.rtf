{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red41\green66\blue119;\red71\green106\blue151;\red100\green100\blue133;
}
\paperw12240\paperh15840\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\b\fs24 \cf0 File Variants
\b0 \
\
Depending on the platform, there may be different files available to build the required functionality. These will typically only be implementation files. For example:\
\
	Core/Timer.h\
	Core/Timer-CoreVideo.cpp\
	Core/Timer-Unix.cpp\
\
Only one of these implementations need to be compiled for a specific platoform. Generally, there will be specific implementations (Core/Timer-CoreVideo.cpp) and generic implementations (Core/Timer-Unix.cpp). You should generally compile the most specific implementation for a platform, rather than the generic implementation.\
\

\b Intrusive Pointers
\b0 \
\
One feature of the Dream framework is automatic memory management. This is done by using reference counted pointers. It is important to understand a few things about the semantics of these "values" in order to get the best performance.\
\
\pard\tx480\pardeftab480\pardirnatural

\f1\fs20 \cf0 \CocoaLigature0 	\cf2 void\cf0  call ();								// Baseline\
	\cf2 void\cf0  callByPtr (\cf3 Object\cf0  * \cf3 object\cf0 );			//  133% slower\
	\cf2 void\cf0  callByRef (\cf3 REF\cf0 (\cf3 Object\cf0 ) & \cf3 object\cf0 );		//  159% slower\
	\cf2 void\cf0  callByVal (\cf3 REF\cf0 (\cf3 Object\cf0 ) \cf3 object\cf0 ); 		// 1276% slower
\f0\fs24 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
Above are three different methods of passing a REF - by value, by reference, and by pointer. They are ordered in terms of speed. It is generally correct to pas REF variables by reference. Because this is a common scenario, there is another macro defined for this exact purpose:\
\
\pard\tx480\pardeftab480\pardirnatural

\f1\fs20 \cf4 \CocoaLigature0 #define REF(cls) Dream::Core::intrusive_ptr<cls>\
#define PTR(cls) REF(cls) &
\f0\fs24 \cf0 \CocoaLigature1 \
\
The ideal way to write a reference counted object as a parameter being passed to a function is to use the PTR syntax:\
\
\pard\tx480\pardeftab480\pardirnatural

\f1\fs20 \cf0 \CocoaLigature0 	\cf2 void\cf0  callByRef (\cf3 PTR\cf0 (\cf3 Object\cf0 ) \cf3 object\cf0 );
\f0\fs24 \CocoaLigature1 \
\
The distinction is that a REF will actively increment the reference count, while a PTR is not incrementing the reference count. It is through this distinction that performance is increased.\
\
See the Class.cpp test case IntrusivePtrPerformance for more details and a benchmark of the different calling conventions.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 Supporting Multiple Graphics Pipelines
\b0 \
\
The Dream framework tries to provide sufficient abstraction for dealing with different platforms.\
\
Here are some references for developing games on the iPhone:\
	{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/iphone/library/technotes/tn2008/tn2230.html#TNTAG12"}}{\fldrslt Technical Note TN2230: Optimizing OpenGL ES for iPhone OS}}\
	{\field{\*\fldinst{HYPERLINK "http://developer.apple.com/iphone/library/qa/qa2008/qa1611.html"}}{\fldrslt Technical Q&A QA1611: Creating textures in the PVRTC compression format}}\
\
Here are some other useful libraries for the iPhone\
	{\field{\*\fldinst{HYPERLINK "http://code.google.com/p/iphone-glu/"}}{\fldrslt iphone-glu - Google Code}}\
	\

\b Shaders and GLSL\

\b0 \
	{\field{\*\fldinst{HYPERLINK "http://www.opengl.org/wiki/GLSL_:_common_mistakes"}}{\fldrslt GLSL : common mistakes - OpenGL.org}}\
\

\b C++ References and Guides\

\b0 \
	{\field{\*\fldinst{HYPERLINK "http://www.cplusplus.com/"}}{\fldrslt cplusplus.com - The C++ Resources Network}}\
}