#!/usr/bin/env ruby

#
#  ext/rakefile
#  This file is part of the "Dream" project, and is released under the MIT license.
#
#  Created by Samuel Williams on 14/08/2010.
#  Copyright (c) 2010 Samuel Williams. All rights reserved.
#

require 'rubygems'
gem 'rexec'

require 'rexec/environment'
require 'stringio'
require 'fileutils'
require 'pathname'
require 'yaml'

EXT_PATH = Pathname.new(__FILE__).dirname
PACKAGES_PATH = EXT_PATH + "packages"
PLATFORMS_PATH = EXT_PATH + "platforms"
OPTION_PATH = EXT_PATH + "opt"

class Package
	ALL = {}
	
	def self.all
		ALL.values
	end
	
	def self.build_order(packages)
		ordered = []
		
		expand = lambda do |name|
			package = packages[name]
			
			unless package
				puts "Couldn't resolve #{name}"
			else
				package.depends.each do |dependency|
					expand.call(dependency)
				end
			
				unless ordered.include? package
					ordered << package
				end
			end
		end
		
		packages.each do |name, package|
			expand.call(name)
		end
		
		return ordered
	end
	
	class BuildError < StandardError
	end
	
	def initialize(name, path)
		@name, @version = name.split('-', 2)
		
		@path = path
		@variants = {}
		@depends = []
		
		@source_path = @path + name
		
		ALL[@name] = self
	end
	
	attr :name
	attr :version
	attr :path
	attr :variants
	
	attr :depends, true
	attr :source_path, true
	
	# For compatibility, now use .source_path
	def src
		@source_path
	end
	
	def self.define(name, &block)
		package = Package.new(name, PACKAGES_PATH + name)
		
		yield(package)
	end
	
	def variant(name, &block)
		@variants[name] = Proc.new
	end
	
	def build(platform)
		puts " Building #{@name} for #{platform.name} ".center(80, "-")
		callback = @variants[platform.name] || @variants[:all]
		
		if (callback)
			callback.call(platform, platform.config)
		else
			raise BuildError.new("Could not find variant #{platform.name}")
		end
	end
	
	def self.require(name)
		unless ALL[name]
			load PACKAGES_PATH + name + "build.rb"
		end
		
		return ALL[name]
	end
end

class Platform
	ALL = {}
	
	def self.all
		ALL.values
	end
	
	class Config
		def initialize
			@values = {}
		end
		
		attr :values
		
		def method_missing(name, *args)
			if name.to_s.match(/^(.*?)(\=)?$/)
				if $2
					return @values[$1] = args[0]
				else
					return @values[$1]
				end
			else
				super(name, *args)
			end
		end
	end
	
	def prefix
		EXT_PATH + @name.to_s
	end
	
	def initialize(name, &block)
		@name = name
		@config = Config.new
		
		yield @config
		
		ALL[name] = self
	end
	
	attr :name
	attr :config
end

GLOBAL_CFLAGS = "-O2 -Wall -Wmissing-prototypes -std=c99 -ffast-math -fno-strict-aliasing -pipe"

# Load all platforms - some might not build on the current host.
Dir[PLATFORMS_PATH + "*.rb"].each do |path|
	require path
end

Dir[PACKAGES_PATH + "*"].each do |path|
	Package.require(File.basename(path))
end

task :default => [:fetch, :build_all, :link_headers]

task :fetch do
	info = YAML::load_file(EXT_PATH + "fetch.yaml")
	
	Package::ALL.each do |name, package|
		# We are interested in full name..
		name = package.name + "-" + package.version
		
		unless info[name]
			puts "Couldn't find information for #{name}!"
			next
		end
		
		url = info[name]['url']
		local_path = package.path + (info[name]['filename'] || File.basename(url))
		
		unless File.exist? local_path
			puts "Downloading #{name} to #{local_path}..."
			puts ["curl", "-L", url, "-o", local_path].join(' ')
			system("curl", "-L", url, "-o", local_path)
			
			puts "Extracting #{name}..."
			system("tar", "-C", package.path, "-xvf",local_path)
		end
	end
end

task :build_all do
	Platform.all.each do |platform|
		order = []
		Package.all.each do |package|
			if package.depends.size == 0
				order << package.name
			else
				package.depends
			end
			package.name
		end
		
		# For testing...
		# next unless platform.name == :darwin_iphonesimulator
		Package.all.each do |package|
			# next unless package.name == "boost_1_43_0"
			package.build(platform)
		end
	end
end

task :link_headers do
	Platform.all.each do |platform|
		include_dir = platform.prefix + "include"
		
		Dir.chdir(include_dir) do
			puts "Linking dream headers for #{platform.name}..."
			sh('ln', '-sf', '../../../include/Dream')
		end
	end
end

task :build, [:package, :platform] do |task, arguments|
	platforms = Platform.all
	packages = Package.all
	
	if arguments[:package]
		packages = [Package::ALL[arguments[:package]]]
	end
	
	if arguments[:platform]
		platforms = [Platform::ALL[arguments[:platform].to_sym]]
	end
	
	platforms.each do |platform|
		packages.each do |package|
			package.build(platform)
		end
	end
end

task :list do
	ordered = Package::build_order(Package::ALL)
	
	ordered.each do |package|
		puts "Package: #{package.name}"
		
		if package.depends.size > 0
			puts "	(depends on #{package.depends.join(', ')})"
		end
	end
end
