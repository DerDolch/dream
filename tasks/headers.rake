
PRIVATE_HEADERS_YAML = File.join(SOURCE_PATH, "private-headers.yaml")

namespace :dream do
	task :copy_headers do
		private_headers = YAML.load_file(PRIVATE_HEADERS_YAML)
		public_path = INCLUDE_PATH

		updated = lambda do |path|
			src_path = path
			dst_path = File.join(public_path, path)

			# If the file doesn't even exist... or check if the src has been updated
			!File.exist?(dst_path) || File.mtime(src_path) > File.mtime(dst_path)
		end

		Dir.chdir(SOURCE_PATH) do
			Dir["**/*.{h}"].each do |path|
				next if private_headers.include?(path)

				dir = File.dirname(path)

				if updated.call(path)
					puts "Copying #{path.dump}"
					FileUtils.mkdir_p(File.join(public_path, dir))
					FileUtils.cp(path, File.join(public_path, path))
				end
			end
		end
	end

	task :update_revision do
		Dir.chdir(PROJECT_PATH) do	
			revision_path = File.join(SOURCE_PATH, "Revision.h")
			current_revision = File.read(revision_path)

			buf = StringIO.new
			buf.puts "// This file is automatically generated"
			buf.puts "namespace Dream {"
			buf.puts "	const char * const SCM_SHORT_ID = " + `git rev-parse --short HEAD`.strip.dump + ";"
			buf.puts "	const char * const SCM_LONG_ID = " + `git rev-parse HEAD`.strip.dump + ";"
			buf.puts "	const char * const BUILD_DATE = " + Time.now.utc.strftime("%Y-%m-%d %H:%M:%S").dump + ";"
			buf.puts "	const char * const BUILD_PLATFORM = " + `uname -prs`.strip.dump + ";"
			buf.puts "}"

			updated_revision = buf.string

			if (current_revision != updated_revision)
				puts "Updating #{revision_path.dump}..."
				File.open(revision_path, "w") { |f| f.write(updated_revision) }
				puts updated_revision
			else
				puts "#{revision_path.dump} is up to date."
			end
		end
	end
end